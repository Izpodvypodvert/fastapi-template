from enum import Enum
from fastapi import APIRouter, Depends, HTTPException, status
from typing import  Any, Callable, Generic, Type, TypeVar
from pydantic import BaseModel

from app.core.exceptions import OpenAPIDocExtraResponse
from app.core.service import AbstractService, AbstractServiceWithUser
from app.users.models import User


S = TypeVar("S", bound="AbstractService")

class BaseRouter(Generic[S]):
    """
    A generic base router class that provides standard CRUD routes (get all items, get an item by ID,
    create, update, and delete). It automates the creation of these routes for a specified model,
    making it easier to implement common operations with minimal setup.

    Type Variables:
    - S (TypeVar): A generic type variable that is bounded by `AbstractService`, representing the type 
      of the service that this router will use for interacting with the data.

    Attributes:
    - model (Type[BaseModel]): The Pydantic model used for read operations.
    - model_create (Type[BaseModel]): The Pydantic model used for create operations.
    - model_update (Type[BaseModel]): The Pydantic model used for update operations.
    - service_dependency (Callable[..., S]): A callable that provides an instance of a service 
      implementing `AbstractService`, allowing interaction with the underlying data store.
    - prefix (str): The URL prefix for the router (e.g., "/items"), which defines the base path for all 
      routes generated by this router.
    - tags (list[Union[str, Enum]] | None): Tags used to categorize the routes in API documentation, 
      helping organize and label different route groups.
    - responses (dict[int | str, dict[str, Any]]): Predefined response models for standard HTTP status 
      codes (e.g., 401 for Unauthorized, 404 for Not Found), used to document responses in the API.
    """
    def __init__(
        self,
        model: Type[BaseModel],
        model_create: Type[BaseModel],
        model_update: Type[BaseModel],
        service_dependency: Callable[..., S],
        prefix: str,
        tags: list[str | Enum] | None,
    ):
        self.router = APIRouter(prefix=prefix, tags=tags)
        self.model = model
        self.model_create = model_create
        self.model_update = model_update
        self.service_dependency = service_dependency
        self.responses: dict[int | str, dict[str, Any]] = {
            401: {"model": OpenAPIDocExtraResponse},
            404: {"model": OpenAPIDocExtraResponse},
        }

        self._create_routes()

    def _create_routes(self):
        """
        Sets up the standard CRUD API routes for the router:
        - GET /: Retrieve a list of all items.
        - GET /{item_id}: Retrieve a single item by its ID.
        - POST /: Create a new item.
        - PUT /{item_id}: Update an existing item by its ID.
        - DELETE /{item_id}: Delete an item by its ID.
        """
        @self.router.get("/", response_model=list[self.model])
        async def get_items(service: S = Depends(self.service_dependency)): 
            return await service.get_all()

        @self.router.get("/{item_id}", response_model=self.model)
        async def get_item(item_id: int, service: S = Depends(self.service_dependency)): 
            item = await service.get_by_id(item_id)
            return item

        @self.router.post("/", response_model=self.model, responses=self.responses)
        async def create_item(
            item: self.model_create, # type: ignore
            service: S = Depends(self.service_dependency)
            ): 
            new_item = await service.create(item)
            return new_item

        @self.router.put("/{item_id}", responses=self.responses)
        async def update_item(
            item_id: int,
            item: self.model_update, # type: ignore
            service: S = Depends(self.service_dependency) 
        ):
            await service.update(item_id, **item.dict())
            return {"message": f"Item has been successfully updated"}

        @self.router.delete(
            "/{item_id}",
            responses=self.responses,
            status_code=status.HTTP_204_NO_CONTENT,
        )
        async def delete_item(
            item_id: int,
            service: S = Depends(self.service_dependency)
            ): 
            deleted_count = await service.delete(item_id)
            if deleted_count == 0:
                raise HTTPException(
                    status_code=status.HTTP_404_NOT_FOUND,
                    detail="Item not found or unauthorized access",
                )


U = TypeVar("U", bound="AbstractServiceWithUser")


class BaseRouterWithUser(BaseRouter, Generic[U]):
    """
    A specialized router class that extends BaseRouter to include user-dependent CRUD operations.
    This class adds user authentication and authorization to all CRUD operations, ensuring that
    user-specific data is handled properly.

    Type Variables:
    - U (TypeVar): A generic type variable that is bounded by `AbstractServiceWithUser`, representing
      the type of the service that this router will use for user-specific operations.

    Attributes:
    - model (Type[BaseModel]): The Pydantic model used for read operations.
    - model_create (Type[BaseModel]): The Pydantic model used for create operations.
    - model_update (Type[BaseModel]): The Pydantic model used for update operations.
    - service_dependency (Callable[..., U]): A callable that provides an instance
      of a service implementing `AbstractServiceWithUser`, which handles user-specific logic.
    - prefix (str): The URL prefix for the router (e.g., "/items").
    - tags (list[Union[str, Enum]] | None): Tags for categorizing the routes in API documentation.
    - current_user (User): Dependency that provides the currently authenticated user, allowing access
      to user-specific data and authorization checks.
    """
    def __init__(
        self,
        model: Type[BaseModel],
        model_create: Type[BaseModel],
        model_update: Type[BaseModel],
        service_dependency: Callable[..., U],
        prefix: str,
        tags: list[str | Enum] | None,
        current_user: User
        ):
        super().__init__(model, model_create, model_update, service_dependency, prefix, tags)
        self.current_user = current_user

    def _create_routes(self):
        @self.router.get("/", response_model=list[self.model])
        async def get_items(
            service: U = Depends(self.service_dependency),
            user: User = Depends(self.current_user)
            ):
            return await service.get_all(user)

        @self.router.get("/{item_id}", response_model=self.model)
        async def get_item(
            item_id: int, 
            service: U = Depends(self.service_dependency),
            user: User = Depends(self.current_user)
        ):
            item = await service.get_by_id(item_id, user)
            return item

        @self.router.post("/", response_model=self.model, responses=self.responses)
        async def create_item(
            item: self.model_create, # type: ignore
            service: U = Depends(self.service_dependency),
            user: User = Depends(self.current_user),
        ):
            new_item = await service.create(item, user)
            return new_item

        @self.router.put("/{item_id}", responses=self.responses)
        async def update_item(
            item_id: int,
            item: self.model_update, # type: ignore
            service: U = Depends(self.service_dependency),
            user: User = Depends(self.current_user),
        ):
            await service.update(item_id, user, **item.dict())
            return {"message": f"Item has been successfully updated"}

        @self.router.delete(
            "/{item_id}",
            responses=self.responses,
            status_code=status.HTTP_204_NO_CONTENT,
        )
        async def delete_item(
            item_id: int,
            service: U = Depends(self.service_dependency),
            user: User = Depends(self.current_user)
        ):
            deleted_count = await service.delete(item_id, user)
            if deleted_count == 0:
                raise HTTPException(
                    status_code=status.HTTP_404_NOT_FOUND,
                    detail="Item not found or unauthorized access",
                )
